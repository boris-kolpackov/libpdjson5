test.options = --json5e

: hash-comment
:
$* <<EOI >>EOO
# begin object
#
{
  # first member
  foo: # this is foo
  # first value
  1    # this is one
  # next comes trailing comma
  , # this is comma
  #bar: 2
  # after last member
}
#
# end object
EOI
  3,  1: {
  5,  3:   foo
  7,  3:   1
 12,  1: }
EOO

: identifier
:
{{
  : basics
  :
  $* <<EOI >>EOO
  {
    foo-bar: 1,
    foo.bar: 2,
    foo-:3,
    foo.:4,
  }
  EOI
    1,  1: {
    2,  3:   foo-bar
    2, 12:   1
    3,  3:   foo.bar
    3, 12:   2
    4,  3:   foo-
    4,  8:   3
    5,  3:   foo.
    5,  8:   4
    6,  1: }
  EOO

  : leading-dash
  :
  $* <'{-foo:1}' >>EOO 2>>EOE !=0
    1,  1: {
  EOO
  <stdin>:1:2: error: expected member name
  EOE

  : leading-dot
  :
  $* <'{.foo:1}' >>EOO 2>>EOE !=0
    1,  1: {
  EOO
  <stdin>:1:2: error: expected member name
  EOE
}}

: implied
:
{{
  # NOTE: only the first member goes through the implied logic.

  : identifier
  :
  $* <<EOI >>EOO
  foo: 1,
  bar: 2
  EOI
    1,  1: {
    1,  1:   foo
    1,  6:   1
    2,  1:   bar
    2,  6:   2
    3,  0: }
  EOO

  : identifier-dash
  :
  $* <<EOI >>EOO
  f-o: 1,
  bar: 2
  EOI
    1,  1: {
    1,  1:   f-o
    1,  6:   1
    2,  1:   bar
    2,  6:   2
    3,  0: }
  EOO

  : identifier-dot
  :
  $* <<EOI >>EOO
  f.o: 1,
  bar: 2
  EOI
    1,  1: {
    1,  1:   f.o
    1,  6:   1
    2,  1:   bar
    2,  6:   2
    3,  0: }
  EOO

  : string-single
  :
  $* <<EOI >>EOO
  'foo': 1,
  bar: 2
  EOI
    1,  1: {
    1,  1:   foo
    1,  8:   1
    2,  1:   bar
    2,  6:   2
    3,  0: }
  EOO

  : string-double
  :
  $* <<EOI >>EOO
  "foo": 1,
  bar: 2
  EOI
    1,  1: {
    1,  1:   foo
    1,  8:   1
    2,  1:   bar
    2,  6:   2
    3,  0: }
  EOO

  : literal
  :
  $* <<EOI >>EOO
  null: 1,
  foo: 2
  EOI
    1,  1: {
    1,  1:   null
    1,  7:   1
    2,  1:   foo
    2,  6:   2
    3,  0: }
  EOO

  : number
  :
  $* <<EOI >>EOO
  Infinity: 1,
  foo: 2
  EOI
    1,  1: {
    1,  1:   Infinity
    1, 11:   1
    2,  1:   foo
    2,  6:   2
    3,  0: }
  EOO

  : trailing-comma
  :
  $* <<EOI >>EOO
  foo: 1,
  EOI
    1,  1: {
    1,  1:   foo
    1,  6:   1
    2,  0: }
  EOO

  : empty
  :
  $* <:'' >>EOO
    1,  1: {
    1,  1: }
  EOO

  : empty-comments
  :
  $* <<EOI >>EOO
  // This feature is enabled by default.
  //
  //foo: true,

  // This feature is disabled by default.
  //
  //bar: false,
  EOI
    1,  1: {
    8,  0: }
  EOO

  : block-comment-after-name
  :
  $* <<EOI >>EOO
  bar/*_value*/: 1
  EOI
    1,  1: {
    1,  1:   bar
    1, 16:   1
    2,  0: }
  EOO

  : line-comment-after-name
  :
  $* <<EOI >>EOO
  bar//_value
  :
  1
  EOI
    1,  1: {
    1,  1:   bar
    2,  1:   1
    3,  0: }
  EOO

  : hash-comment-after-name
  :
  $* <<EOI >>EOO
  bar#_value
  :
  1
  EOI
    1,  1: {
    1,  1:   bar
    2,  1:   1
    3,  0: }
  EOO

  : not-implied-string
  :
  $* <<EOI >>EOO
  "foo"
  EOI
    1,  1: "foo"
  EOO

  : not-implied-string-comment
  :
  $* <<EOI >>EOO
  "foo" //comment
  EOI
    1,  1: "foo"
  EOO

  : not-implied-string-comment-eof
  :
  $* <:'"foo" //comment' >>EOO
    1,  1: "foo"
  EOO

  : not-implied-string-comment-dangling
  :
  $* <:'"foo" /*comment*' 2>>EOE !=0
  <stdin>:1:16: error: unexpected end of text before '*/'
  EOE

  : not-implied-name
  :
  $* <<EOI >>EOO
  true
  EOI
    1,  1: <true>
  EOO

  : not-implied-name-comment
  :
  $* <<EOI >>EOO
  true //comment
  EOI
    1,  1: <true>
  EOO

  : not-implied-name-comment-eof
  :
  $* <:'true //comment' >>EOO
    1,  1: <true>
  EOO

  : not-implied-name-comment-dangling
  :
  $* <:'true /*comment*' 2>>EOE !=0
  <stdin>:1:15: error: unexpected end of text before '*/'
  EOE

  : explicit-end
  :
  $* <<EOI >>EOO 2>>EOE !=0
  foo: 1
  }
  EOI
    1,  1: {
    1,  1:   foo
    1,  6:   1
  EOO
  <stdin>:2:1: error: explicit '}' in implied object
  EOE

  : junk-before-comma
  :
  $* <<EOI >>EOO 2>>EOE !=0
  foo: 1 123
  }
  EOI
    1,  1: {
    1,  1:   foo
    1,  6:   1
  EOO
  <stdin>:1:8: error: expected ',' after member value
  EOE

  : diag
  :
  : Test that diagnostics (both messages and positions) issued by the implied
  : object handling logic matches that of plain JSON5 logic.
  :
  # Note: to make sure positions match, run both with and without --json5e.
  #
  {{
    : junk
    :
    $* <:"TRUE" 2>>EOE !=0
    <stdin>:1:1: error: unexpected byte 'T' in value
    EOE

    : pos-sub
    :
    $* <:"truth" 2>>EOE !=0
    <stdin>:1:4: error: expected 'e' instead of byte 't' in 'true'
    EOE

    : pos-sup
    :
    $* <:"truest" 2>>EOE !=0
    <stdin>:1:5: error: expected end of text instead of byte 's'
    EOE

    : pos-nextc
    :
    $* <:"tru " 2>>EOE !=0
    <stdin>:1:4: error: expected 'e' instead of byte ' ' in 'true'
    EOE

    : pos-eof
    :
    $* <:"tru" 2>>EOE !=0
    <stdin>:1:3: error: expected 'e' instead of end of text in 'true'
    EOE

    : pos-nextc-newline
    :
    $* <:"tru$\n" 2>>EOE !=0
    <stdin>:1:4: error: expected 'e' instead of byte '
    ' in 'true'
    EOE

    : not-comment
    :
    $* <:"true /comment" 2>>EOE !=0
    <stdin>:1:6: error: expected end of text instead of byte '/'
    EOE

    : not-comment-eof
    :
    $* <:"true/" 2>>EOE !=0
    <stdin>:1:5: error: expected end of text instead of byte '/'
    EOE

    : not-value-comment
    :
    $* <:"tue /comment" 2>>EOE !=0
    <stdin>:1:2: error: expected 'r' instead of byte 'u' in 'true'
    EOE

    : identifier-dash
    :
    $* <:"true-1" 2>>EOE !=0
    <stdin>:1:5: error: expected end of text instead of byte '-'
    EOE

    : identifier-dot
    :
    $* <:"true.1" 2>>EOE !=0
    <stdin>:1:5: error: expected end of text instead of byte '.'
    EOE
  }}
}}
